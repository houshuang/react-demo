{"version":3,"names":[],"mappings":"","sources":["dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/dist/umd/html-text-collab-ext.js"],"sourcesContent":["/**!\nÂ© 2018 Convergence Labs, Inc.\n@version 0.1.1\n@license MIT\n*/\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = global || self, factory(global.HtmlTextCollabExt = {}));\n}(this, function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    function unwrapExports (x) {\n    \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n    }\n\n    function createCommonjsModule(fn, module) {\n    \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    var textareaCaret = createCommonjsModule(function (module) {\n    /* jshint browser: true */\n\n    (function () {\n\n    // We'll copy the properties below into the mirror div.\n    // Note that some browsers, such as Firefox, do not concatenate properties\n    // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n    // so we have to list every single property explicitly.\n    var properties = [\n      'direction',  // RTL support\n      'boxSizing',\n      'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n      'height',\n      'overflowX',\n      'overflowY',  // copy the scrollbar for IE\n\n      'borderTopWidth',\n      'borderRightWidth',\n      'borderBottomWidth',\n      'borderLeftWidth',\n      'borderStyle',\n\n      'paddingTop',\n      'paddingRight',\n      'paddingBottom',\n      'paddingLeft',\n\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n      'fontStyle',\n      'fontVariant',\n      'fontWeight',\n      'fontStretch',\n      'fontSize',\n      'fontSizeAdjust',\n      'lineHeight',\n      'fontFamily',\n\n      'textAlign',\n      'textTransform',\n      'textIndent',\n      'textDecoration',  // might not make a difference, but better be safe\n\n      'letterSpacing',\n      'wordSpacing',\n\n      'tabSize',\n      'MozTabSize'\n\n    ];\n\n    var isBrowser = (typeof window !== 'undefined');\n    var isFirefox = (isBrowser && window.mozInnerScreenX != null);\n\n    function getCaretCoordinates(element, position, options) {\n      if (!isBrowser) {\n        throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');\n      }\n\n      var debug = options && options.debug || false;\n      if (debug) {\n        var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n        if (el) el.parentNode.removeChild(el);\n      }\n\n      // The mirror div will replicate the textarea's style\n      var div = document.createElement('div');\n      div.id = 'input-textarea-caret-position-mirror-div';\n      document.body.appendChild(div);\n\n      var style = div.style;\n      var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n      var isInput = element.nodeName === 'INPUT';\n\n      // Default textarea styles\n      style.whiteSpace = 'pre-wrap';\n      if (!isInput)\n        style.wordWrap = 'break-word';  // only for textarea-s\n\n      // Position off-screen\n      style.position = 'absolute';  // required to return coordinates properly\n      if (!debug)\n        style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n      // Transfer the element's properties to the div\n      properties.forEach(function (prop) {\n        if (isInput && prop === 'lineHeight') {\n          // Special case for <input>s because text is rendered centered and line height may be != height\n          style.lineHeight = computed.height;\n        } else {\n          style[prop] = computed[prop];\n        }\n      });\n\n      if (isFirefox) {\n        // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n        if (element.scrollHeight > parseInt(computed.height))\n          style.overflowY = 'scroll';\n      } else {\n        style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n      }\n\n      div.textContent = element.value.substring(0, position);\n      // The second special handling for input type=\"text\" vs textarea:\n      // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n      if (isInput)\n        div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n\n      var span = document.createElement('span');\n      // Wrapping must be replicated *exactly*, including when a long word gets\n      // onto the next line, with whitespace at the end of the line before (#7).\n      // The  *only* reliable way to do that is to copy the *entire* rest of the\n      // textarea's content into the <span> created at the caret position.\n      // For inputs, just '.' would be enough, but no need to bother.\n      span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n      div.appendChild(span);\n\n      var coordinates = {\n        top: span.offsetTop + parseInt(computed['borderTopWidth']),\n        left: span.offsetLeft + parseInt(computed['borderLeftWidth']),\n        height: parseInt(computed['lineHeight'])\n      };\n\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      } else {\n        document.body.removeChild(div);\n      }\n\n      return coordinates;\n    }\n\n    {\n      module.exports = getCaretCoordinates;\n    }\n\n    }());\n    });\n\n    // @ts-ignore\r\n    /*\r\n     * Computes the dimensions of the text selection.  Each line in the textarea has its own\r\n     * selection dimensions, which are intended to be used to render a div with the specified\r\n     * position, dimensions and background color.\r\n     *\r\n     * This has only been tested on a textarea, but should be able to be adapted to be used\r\n     * in other HTML form elements.\r\n     *\r\n     * TODO unit test, this is pretty brittle\r\n     */\r\n    var SelectionComputer = /** @class */ (function () {\r\n        function SelectionComputer(element, start, end) {\r\n            this.element = element;\r\n            this.start = start;\r\n            this.end = end;\r\n            this.startCoordinates = textareaCaret(element, start);\r\n            this.endCoordinates = textareaCaret(element, end);\r\n            this.lineHeight = this.startCoordinates.height;\r\n            this.elementPaddingLeft = parseFloat(element.style.paddingLeft) || 0;\r\n            this.elementPaddingRight = parseFloat(element.style.paddingRight) || 0;\r\n            this.elementPaddingX = this.elementPaddingLeft + this.elementPaddingRight;\r\n            this.selectionRows = [];\r\n            // Figure out whether this selection spans more than one \"row\", as determined by\r\n            // the presence of a newline character. The computation of single line selections\r\n            // is slightly different than for multiple line selections.\r\n            var selectedText = element.value.substr(start, end - start);\r\n            if (selectedText.indexOf('\\n') < 0) {\r\n                this.appendSingleLineSelection(this.startCoordinates, this.endCoordinates);\r\n            }\r\n            else {\r\n                this.buildMultiRowSelection();\r\n            }\r\n        }\r\n        SelectionComputer.calculateSelection = function (element, start, end) {\r\n            var computer = new SelectionComputer(element, start, end);\r\n            return computer.selectionRows;\r\n        };\r\n        SelectionComputer.prototype.appendSingleLineSelection = function (startCoordinates, endCoordinates) {\r\n            var _a;\r\n            (_a = this.selectionRows).push.apply(_a, this.buildSingleLineSelection(startCoordinates, endCoordinates));\r\n        };\r\n        SelectionComputer.prototype.buildSingleLineSelection = function (startCoordinates, endCoordinates) {\r\n            // does this line wrap? If not, we can just calculate the row selection based on\r\n            // the provided coordinates.\r\n            if (startCoordinates.top === endCoordinates.top) {\r\n                return [{\r\n                        width: endCoordinates.left - startCoordinates.left,\r\n                        top: startCoordinates.top,\r\n                        left: startCoordinates.left,\r\n                        height: this.lineHeight\r\n                    }];\r\n            }\r\n            else {\r\n                return this.buildWrappedLineSelections(startCoordinates, endCoordinates);\r\n            }\r\n        };\r\n        /**\r\n         * Wrapped lines have a more complex computation since we have to create multiple\r\n         * rows.\r\n         *\r\n         * @param startCoordinates\r\n         * @param endCoordinates\r\n         */\r\n        SelectionComputer.prototype.buildWrappedLineSelections = function (startCoordinates, endCoordinates) {\r\n            var rows = [];\r\n            // the first line just goes the full width of the textarea\r\n            rows.push({\r\n                width: this.element.scrollWidth - this.elementPaddingRight - startCoordinates.left,\r\n                top: startCoordinates.top,\r\n                left: startCoordinates.left,\r\n                height: this.lineHeight\r\n            });\r\n            // If the selection contains one or more rows that span the entire textarea,\r\n            // calculate a single selection element, which may actually span multiple rows,\r\n            // but fills the width of the textarea.\r\n            if (endCoordinates.top > startCoordinates.top + this.lineHeight) {\r\n                rows.push({\r\n                    width: this.element.scrollWidth - this.elementPaddingX,\r\n                    left: this.elementPaddingLeft,\r\n                    top: startCoordinates.top + this.lineHeight,\r\n                    height: endCoordinates.top - startCoordinates.top - this.lineHeight\r\n                });\r\n            }\r\n            // The last line starts at the left edge of the textarea and doesn't span the\r\n            // entire width of the textarea\r\n            rows.push({\r\n                width: endCoordinates.left - this.elementPaddingLeft,\r\n                top: endCoordinates.top,\r\n                left: this.elementPaddingLeft,\r\n                height: this.lineHeight\r\n            });\r\n            return rows;\r\n        };\r\n        SelectionComputer.prototype.buildMultiRowSelection = function () {\r\n            var currentCoordinates = this.startCoordinates;\r\n            var currentIndex = +this.start;\r\n            // build one or more selection elements for each row (as determined by newline\r\n            // characters)\r\n            while (currentCoordinates.top < this.endCoordinates.top) {\r\n                var nextLineBreakPosition = this.element.value.indexOf('\\n', currentIndex);\r\n                var endOfLinePosition = this.element.value.length;\r\n                if (nextLineBreakPosition >= 0) {\r\n                    endOfLinePosition = nextLineBreakPosition;\r\n                }\r\n                if (endOfLinePosition > this.end) {\r\n                    endOfLinePosition = this.end;\r\n                }\r\n                var endOfLineCoordinates = textareaCaret(this.element, endOfLinePosition);\r\n                // console.log('target of line position', endOfLinePosition, 'coords', endOfLineCoordinates);\r\n                // This \"single line\" may actually wrap multiple lines of the textarea\r\n                this.appendSingleLineSelection(currentCoordinates, endOfLineCoordinates);\r\n                currentIndex = endOfLinePosition + 1;\r\n                currentCoordinates = textareaCaret(this.element, currentIndex);\r\n            }\r\n            if (currentIndex < this.end) {\r\n                var lastLine = {\r\n                    width: this.endCoordinates.left - currentCoordinates.left,\r\n                    top: currentCoordinates.top,\r\n                    left: currentCoordinates.left,\r\n                    height: this.lineHeight\r\n                };\r\n                this.selectionRows.push(lastLine);\r\n            }\r\n        };\r\n        return SelectionComputer;\r\n    }());\n\n    var CollaboratorSelection = /** @class */ (function () {\r\n        function CollaboratorSelection(textInput, overlayContainer, color, label, options) {\r\n            this._label = label;\r\n            this._textInput = textInput;\r\n            this._color = color;\r\n            this._cursor = null;\r\n            this._selection = null;\r\n            this._rows = [];\r\n            this._container = overlayContainer;\r\n            options = options || {};\r\n            this._margin = options.margin || 5;\r\n            this._tooltipTimeout = null;\r\n            this._cursorElement = this._container.ownerDocument.createElement(\"div\");\r\n            this._cursorElement.className = \"collaborator-cursor\";\r\n            this._cursorElement.style.backgroundColor = this._color;\r\n            this._tooltipElement = this._container.ownerDocument.createElement(\"div\");\r\n            this._tooltipElement.innerHTML = label;\r\n            this._tooltipElement.className = \"collaborator-cursor-tooltip\";\r\n            this._tooltipElement.style.backgroundColor = this._color;\r\n            this.hideCursorTooltip();\r\n            this.refresh();\r\n        }\r\n        CollaboratorSelection.prototype.showSelection = function () {\r\n            this._rows.forEach(function (row) {\r\n                row.element.style.visibility = \"visible\";\r\n            });\r\n        };\r\n        CollaboratorSelection.prototype.hideSelection = function () {\r\n            this._rows.forEach(function (row) {\r\n                row.element.style.visibility = \"hidden\";\r\n            });\r\n        };\r\n        CollaboratorSelection.prototype.showCursor = function () {\r\n            this._cursorElement.style.visibility = \"visible\";\r\n        };\r\n        CollaboratorSelection.prototype.hideCursor = function () {\r\n            this._cursorElement.style.visibility = \"hidden\";\r\n        };\r\n        CollaboratorSelection.prototype.showCursorToolTip = function () {\r\n            this._clearToolTipTimeout();\r\n            this._tooltipElement.style.opacity = \"1\";\r\n        };\r\n        CollaboratorSelection.prototype.flashCursorToolTip = function (duration) {\r\n            var _this = this;\r\n            this.showCursorToolTip();\r\n            this._clearToolTipTimeout();\r\n            this._tooltipTimeout = setTimeout(function () { return _this.hideCursorTooltip(); }, duration * 1000);\r\n        };\r\n        CollaboratorSelection.prototype.hideCursorTooltip = function () {\r\n            this._clearToolTipTimeout();\r\n            this._tooltipElement.style.opacity = \"0\";\r\n        };\r\n        CollaboratorSelection.prototype._clearToolTipTimeout = function () {\r\n            if (this._tooltipTimeout !== null) {\r\n                clearTimeout(this._tooltipTimeout);\r\n                this._tooltipTimeout = null;\r\n            }\r\n        };\r\n        CollaboratorSelection.prototype.setColor = function (color) {\r\n            var _this = this;\r\n            this._color = color;\r\n            this._rows.forEach(function (row) {\r\n                row.element.style.background = _this._color;\r\n            });\r\n            this._cursorElement.style.background = this._color;\r\n            this._tooltipElement.style.background = this._color;\r\n        };\r\n        CollaboratorSelection.prototype.setSelection = function (selection) {\r\n            if (selection === null) {\r\n                this._cursor = null;\r\n                this._selection = null;\r\n            }\r\n            else {\r\n                this._cursor = selection.target;\r\n                this._selection = __assign({}, selection);\r\n            }\r\n            this.refresh();\r\n        };\r\n        CollaboratorSelection.prototype.getSelection = function () {\r\n            return __assign({}, this._selection);\r\n        };\r\n        CollaboratorSelection.prototype.clearSelection = function () {\r\n            this.setSelection(null);\r\n        };\r\n        CollaboratorSelection.prototype.refresh = function () {\r\n            this._updateCursor();\r\n            this._updateSelection();\r\n        };\r\n        CollaboratorSelection.prototype._updateCursor = function () {\r\n            if (this._cursor === null && this._container.contains(this._cursorElement)) {\r\n                this._container.removeChild(this._cursorElement);\r\n                this._container.removeChild(this._tooltipElement);\r\n            }\r\n            else {\r\n                if (!this._cursorElement.parentElement) {\r\n                    this._container.append(this._cursorElement);\r\n                    this._container.append(this._tooltipElement);\r\n                }\r\n                var cursorCoords = textareaCaret(this._textInput, this._cursor);\r\n                this._cursorElement.style.height = cursorCoords.height + \"px\";\r\n                this._cursorElement.style.top = cursorCoords.top + \"px\";\r\n                var cursorLeft = (cursorCoords.left - this._cursorElement.offsetWidth / 2);\r\n                this._cursorElement.style.left = cursorLeft + \"px\";\r\n                var toolTipTop = cursorCoords.top - this._tooltipElement.offsetHeight;\r\n                if (toolTipTop + this._container.offsetTop < this._margin) {\r\n                    toolTipTop = cursorCoords.top + cursorCoords.height;\r\n                }\r\n                var toolTipLeft = cursorLeft;\r\n                if (toolTipLeft + this._tooltipElement.offsetWidth > this._container.offsetWidth - this._margin) {\r\n                    toolTipLeft = cursorLeft + this._cursorElement.offsetWidth - this._tooltipElement.offsetWidth;\r\n                }\r\n                this._tooltipElement.style.top = toolTipTop + \"px\";\r\n                this._tooltipElement.style.left = toolTipLeft + \"px\";\r\n            }\r\n        };\r\n        CollaboratorSelection.prototype._updateSelection = function () {\r\n            var _this = this;\r\n            if (this._selection === null) {\r\n                this._rows.forEach(function (row) { return row.element.parentElement.removeChild(row.element); });\r\n                this._rows.splice(0, this._rows.length);\r\n            }\r\n            else {\r\n                var start = void 0;\r\n                var end = void 0;\r\n                if (this._selection.anchor > this._selection.target) {\r\n                    start = Number(this._selection.target);\r\n                    end = Number(this._selection.anchor);\r\n                }\r\n                else {\r\n                    start = Number(this._selection.anchor);\r\n                    end = Number(this._selection.target);\r\n                }\r\n                var newRows = SelectionComputer.calculateSelection(this._textInput, start, end);\r\n                // Adjust size of rows as needed\r\n                var delta = newRows.length - this._rows.length;\r\n                if (delta > 0) {\r\n                    if (this._rows.length === 0 || this._rowsEqual(newRows[0], this._rows[0].rowData)) {\r\n                        this._addNewRows(delta, true);\r\n                    }\r\n                    else {\r\n                        this._addNewRows(delta, false);\r\n                    }\r\n                }\r\n                else if (delta < 0) {\r\n                    var removed = null;\r\n                    if (this._rowsEqual(newRows[0], this._rows[0].rowData)) {\r\n                        // Take from the target.\r\n                        removed = this._rows.splice(this._rows.length - 1 + delta, delta * -1);\r\n                    }\r\n                    else {\r\n                        removed = this._rows.splice(0, delta * -1);\r\n                    }\r\n                    removed.forEach(function (row) { return row.element.parentElement.removeChild(row.element); });\r\n                }\r\n                // Now compare each row and see if we need an update.\r\n                newRows.forEach(function (newRowData, index) {\r\n                    var row = _this._rows[index];\r\n                    _this._updateRow(newRowData, row);\r\n                });\r\n            }\r\n        };\r\n        CollaboratorSelection.prototype._addNewRows = function (count, append) {\r\n            for (var i = 0; i < count; i++) {\r\n                var element = this._container.ownerDocument.createElement(\"div\");\r\n                element.style.position = \"absolute\";\r\n                element.style.backgroundColor = this._color;\r\n                element.style.opacity = \"0.25\";\r\n                this._container.append(element);\r\n                var rowData = { height: 0, width: 0, top: 0, left: 0 };\r\n                var newRow = {\r\n                    element: element,\r\n                    rowData: rowData\r\n                };\r\n                if (append) {\r\n                    this._rows.push(newRow);\r\n                }\r\n                else {\r\n                    this._rows.unshift(newRow);\r\n                }\r\n            }\r\n        };\r\n        CollaboratorSelection.prototype._rowsEqual = function (a, b) {\r\n            return a.height === b.height &&\r\n                a.width === b.width &&\r\n                a.top === b.top &&\r\n                a.left === b.left;\r\n        };\r\n        CollaboratorSelection.prototype._updateRow = function (newRowData, row) {\r\n            if (newRowData.height !== row.rowData.height) {\r\n                row.rowData.height = newRowData.height;\r\n                row.element.style.height = newRowData.height + \"px\";\r\n            }\r\n            if (newRowData.width !== row.rowData.width) {\r\n                row.rowData.width = newRowData.width;\r\n                row.element.style.width = newRowData.width + \"px\";\r\n            }\r\n            if (newRowData.top !== row.rowData.top) {\r\n                row.rowData.top = newRowData.top;\r\n                row.element.style.top = newRowData.top + \"px\";\r\n            }\r\n            if (newRowData.left !== row.rowData.left) {\r\n                row.rowData.left = newRowData.left;\r\n                row.element.style.left = newRowData.left + \"px\";\r\n            }\r\n        };\r\n        return CollaboratorSelection;\r\n    }());\n\n    var IndexUtils = /** @class */ (function () {\r\n        function IndexUtils() {\r\n        }\r\n        IndexUtils.transformIndexOnInsert = function (index, insertIndex, value) {\r\n            if (insertIndex <= index) {\r\n                return index + value.length;\r\n            }\r\n            return index;\r\n        };\r\n        IndexUtils.transformIndexOnDelete = function (index, deleteIndex, length) {\r\n            if (index > deleteIndex) {\r\n                return index - Math.min(index - deleteIndex, length);\r\n            }\r\n            return index;\r\n        };\r\n        return IndexUtils;\r\n    }());\n\n    var CollaborativeSelectionManager = /** @class */ (function () {\r\n        function CollaborativeSelectionManager(options) {\r\n            var _this = this;\r\n            this._checkSelection = function () {\r\n                setTimeout(function () {\r\n                    var changed = _this._textElement.selectionStart !== _this._selectionAnchor ||\r\n                        _this._textElement.selectionEnd !== _this._selectionTarget;\r\n                    if (changed) {\r\n                        if (_this._selectionAnchor === _this._textElement.selectionStart) {\r\n                            _this._selectionAnchor = _this._textElement.selectionStart;\r\n                            _this._selectionTarget = _this._textElement.selectionEnd;\r\n                        }\r\n                        else {\r\n                            _this._selectionAnchor = _this._textElement.selectionEnd;\r\n                            _this._selectionTarget = _this._textElement.selectionStart;\r\n                        }\r\n                        _this._onSelection({\r\n                            anchor: _this._selectionAnchor,\r\n                            target: _this._selectionTarget\r\n                        });\r\n                    }\r\n                }, 0);\r\n            };\r\n            this._onMouseMove = function () {\r\n                _this._checkResize();\r\n                _this._checkSelection();\r\n            };\r\n            this._checkResize = function () {\r\n                if (_this._textElement.offsetWidth !== _this._overlayContainer.offsetWidth ||\r\n                    _this._textElement.offsetHeight !== _this._overlayContainer.offsetHeight) {\r\n                    _this._updateOverlay();\r\n                    _this._collaborators.forEach(function (renderer) { return renderer.refresh(); });\r\n                }\r\n            };\r\n            this._collaborators = new Map();\r\n            this._textElement = options.control;\r\n            // TODO handle the line height better. The issue here\r\n            // is that the textarea-caret library can't handle\r\n            // a non-number.\r\n            var computed = window.getComputedStyle(this._textElement);\r\n            if (computed.lineHeight === \"normal\") {\r\n                throw new Error(\"Text areas must have a numeric line-height.\");\r\n            }\r\n            this._onSelection = options.onSelectionChanged;\r\n            this._selectionAnchor = this._textElement.selectionStart;\r\n            this._selectionTarget = this._textElement.selectionEnd;\r\n            this._overlayContainer = this._textElement.ownerDocument.createElement(\"div\");\r\n            this._overlayContainer.className = \"text-collab-ext\";\r\n            this._textElement.parentElement.append(this._overlayContainer);\r\n            this._scroller = this._textElement.ownerDocument.createElement(\"div\");\r\n            this._scroller.className = \"text-collab-ext-scroller\";\r\n            this._overlayContainer.append(this._scroller);\r\n            // Provide resize handling. After the mose down, we register for mouse\r\n            // movement and check if we have resized. We then listen for a mouse up\r\n            // to unregister.\r\n            this._textElement.addEventListener(\"mousedown\", function () {\r\n                window.addEventListener(\"mousemove\", _this._onMouseMove);\r\n            });\r\n            window.addEventListener(\"mouseup\", function () {\r\n                window.removeEventListener(\"mousemove\", _this._onMouseMove);\r\n                _this._checkResize();\r\n            });\r\n            this._textElement.addEventListener(\"scroll\", function () { return _this._updateScroller(); });\r\n            this._textElement.addEventListener(\"keydown\", this._checkSelection);\r\n            this._textElement.addEventListener(\"click\", this._checkSelection);\r\n            this._textElement.addEventListener(\"focus\", this._checkSelection);\r\n            this._textElement.addEventListener(\"blur\", this._checkSelection);\r\n            this._updateOverlay();\r\n        }\r\n        CollaborativeSelectionManager.prototype.addCollaborator = function (id, label, color, selection) {\r\n            if (this._collaborators.has(id)) {\r\n                throw new Error(\"A collaborator with the specified id already exists: \" + id);\r\n            }\r\n            var collaborator = new CollaboratorSelection(this._textElement, this._scroller, color, label, { margin: 5 });\r\n            this._collaborators.set(id, collaborator);\r\n            if (selection !== undefined && selection !== null) {\r\n                collaborator.setSelection(selection);\r\n            }\r\n            return collaborator;\r\n        };\r\n        CollaborativeSelectionManager.prototype.getCollaborator = function (id) {\r\n            return this._collaborators.get(id);\r\n        };\r\n        CollaborativeSelectionManager.prototype.removeCollaborator = function (id) {\r\n            var renderer = this._collaborators.get(id);\r\n            if (renderer !== undefined) {\r\n                renderer.clearSelection();\r\n                this._collaborators.delete(id);\r\n            }\r\n            else {\r\n                throw new Error(\"Unknown collaborator: \" + id);\r\n            }\r\n        };\r\n        CollaborativeSelectionManager.prototype.getSelection = function () {\r\n            return {\r\n                anchor: this._selectionAnchor,\r\n                target: this._selectionTarget\r\n            };\r\n        };\r\n        CollaborativeSelectionManager.prototype.show = function () {\r\n            this._overlayContainer.style.visibility = \"visible\";\r\n        };\r\n        CollaborativeSelectionManager.prototype.hide = function () {\r\n            this._overlayContainer.style.visibility = \"hidden\";\r\n        };\r\n        CollaborativeSelectionManager.prototype.dispose = function () {\r\n            this._overlayContainer.parentElement.removeChild(this._overlayContainer);\r\n        };\r\n        CollaborativeSelectionManager.prototype.updateSelectionsOnInsert = function (index, value) {\r\n            this._collaborators.forEach(function (collaborator) {\r\n                var selection = collaborator.getSelection();\r\n                var anchor = IndexUtils.transformIndexOnInsert(selection.anchor, index, value);\r\n                var target = IndexUtils.transformIndexOnInsert(selection.target, index, value);\r\n                collaborator.setSelection({ anchor: anchor, target: target });\r\n            });\r\n        };\r\n        CollaborativeSelectionManager.prototype.updateSelectionsOnDelete = function (index, length) {\r\n            this._collaborators.forEach(function (collaborator) {\r\n                var selection = collaborator.getSelection();\r\n                var anchor = IndexUtils.transformIndexOnDelete(selection.anchor, index, length);\r\n                var target = IndexUtils.transformIndexOnDelete(selection.target, index, length);\r\n                collaborator.setSelection({ anchor: anchor, target: target });\r\n            });\r\n        };\r\n        CollaborativeSelectionManager.prototype._updateOverlay = function () {\r\n            var top = this._textElement.offsetTop;\r\n            var left = this._textElement.offsetLeft;\r\n            var height = this._textElement.offsetHeight;\r\n            var width = this._textElement.offsetWidth;\r\n            this._overlayContainer.style.top = top + \"px\";\r\n            this._overlayContainer.style.left = left + \"px\";\r\n            this._overlayContainer.style.height = height + \"px\";\r\n            this._overlayContainer.style.width = width + \"px\";\r\n        };\r\n        CollaborativeSelectionManager.prototype._updateScroller = function () {\r\n            this._scroller.style.top = (this._textElement.scrollTop * -1) + \"px\";\r\n            this._scroller.style.left = (this._textElement.scrollLeft * -1) + \"px\";\r\n        };\r\n        return CollaborativeSelectionManager;\r\n    }());\n\n    var StringChangeDetector_1 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n    var StringChangeDetector = exports.StringChangeDetector = function () {\n      function StringChangeDetector(options) {\n        _classCallCheck(this, StringChangeDetector);\n\n        if (!options) {\n          throw new Error(\"options must be defined\");\n        }\n\n        if (typeof options.onInsert !== \"function\") {\n          throw new Error(\"options.onInsert must be a function\");\n        }\n\n        if (typeof options.onRemove !== \"function\") {\n          throw new Error(\"options.onRemove must be a function\");\n        }\n\n        if (typeof options.value !== \"string\") {\n          throw new Error(\"options.value must be a string\");\n        }\n\n        this._onInsert = options.onInsert;\n        this._onRemove = options.onRemove;\n        this._value = options.value;\n      }\n\n      /**\n       * Inserts a string into the current value at the specified index.\n       *\n       * @param index {number}\n       *    The index in the string to insert into.\n       * @param value {string}\n       *   The value to insert into the string.\n       */\n\n\n      _createClass(StringChangeDetector, [{\n        key: \"insertText\",\n        value: function insertText(index, value) {\n          var oldVal = this._value;\n          var newVal = oldVal.substring(0, index) + value + oldVal.substring(index, oldVal.length);\n          this.setValue(newVal);\n        }\n\n        /**\n         * Removes a specified number of characters from the current string at\n         * a specific location.\n         *\n         * @param index {number}\n         *    The index in the string to remove characters.\n         * @param length {number}\n         *   The number of characters to remove.\n         */\n\n      }, {\n        key: \"removeText\",\n        value: function removeText(index, length) {\n          var oldVal = this._value;\n          var newVal = oldVal.substring(0, index) + oldVal.substring(index + length, oldVal.length);\n          this.setValue(newVal);\n        }\n\n        /**\n         * Sets the current value of the string.\n         *\n         * @param value {string}\n         *   The new value of the string.\n         */\n\n      }, {\n        key: \"setValue\",\n        value: function setValue(value) {\n          this._value = value;\n        }\n\n        /**\n         * Gets the current value of the string.\n         *\n         * @returns {string}\n         */\n\n      }, {\n        key: \"getValue\",\n        value: function getValue() {\n          return this._value;\n        }\n\n        /**\n         * Process the new value of the string after a single edit.\n         *\n         * @param newValue {string}\n         *   The new value to process.\n         */\n\n      }, {\n        key: \"processNewValue\",\n        value: function processNewValue(newValue) {\n          var commonEnd = 0;\n          var commonStart = 0;\n\n          if (this._value === newValue) {\n            return;\n          }\n\n          while (this._value.charAt(commonStart) === newValue.charAt(commonStart)) {\n            commonStart++;\n          }\n\n          while (this._value.charAt(this._value.length - 1 - commonEnd) === newValue.charAt(newValue.length - 1 - commonEnd) && commonEnd + commonStart < this._value.length && commonEnd + commonStart < newValue.length) {\n            commonEnd++;\n          }\n\n          // Characters were removed.\n          if (this._value.length !== commonStart + commonEnd) {\n            if (this._onRemove) {\n              this._onRemove(commonStart, this._value.length - commonStart - commonEnd);\n            }\n          }\n\n          // Characters were added\n          if (newValue.length !== commonStart + commonEnd) {\n            if (this._onInsert) {\n              this._onInsert(commonStart, newValue.slice(commonStart, newValue.length - commonEnd));\n            }\n          }\n\n          this._value = newValue;\n        }\n      }]);\n\n      return StringChangeDetector;\n    }();\n\n    });\n\n    unwrapExports(StringChangeDetector_1);\n    var StringChangeDetector_2 = StringChangeDetector_1.StringChangeDetector;\n\n    var lib = StringChangeDetector_1.StringChangeDetector;\n\n    // @ts-ignore\r\n    var TextInputManager = /** @class */ (function () {\r\n        /**\r\n         *\r\n         * @param options\r\n         */\r\n        function TextInputManager(options) {\r\n            var _this = this;\r\n            this._onLocalInput = function () {\r\n                _this._changeDetector.processNewValue(_this._control.value);\r\n            };\r\n            this._control = options.control;\r\n            this._onLocalInsert = options.onInsert;\r\n            this._onLocalDelete = options.onDelete;\r\n            this._changeDetector = null;\r\n            this.bind();\r\n        }\r\n        TextInputManager.prototype.bind = function () {\r\n            this._changeDetector = new lib({\r\n                value: this._control.value,\r\n                onInsert: this._onLocalInsert,\r\n                onRemove: this._onLocalDelete\r\n            });\r\n            this._control.addEventListener(\"input\", this._onLocalInput);\r\n        };\r\n        TextInputManager.prototype.unbind = function () {\r\n            this._control.removeEventListener(\"input\", this._onLocalInput);\r\n            this._changeDetector = null;\r\n        };\r\n        TextInputManager.prototype.insertText = function (index, value) {\r\n            this._assertBound();\r\n            var _a = this._getSelection(), start = _a.start, end = _a.end;\r\n            var xStart = IndexUtils.transformIndexOnInsert(start, index, value);\r\n            var xEnd = IndexUtils.transformIndexOnInsert(end, index, value);\r\n            this._changeDetector.insertText(index, value);\r\n            this._updateControl();\r\n            this._setTextSelection(xStart, xEnd);\r\n        };\r\n        TextInputManager.prototype.deleteText = function (index, length) {\r\n            this._assertBound();\r\n            var _a = this._getSelection(), start = _a.start, end = _a.end;\r\n            var xStart = IndexUtils.transformIndexOnDelete(start, index, length);\r\n            var xEnd = IndexUtils.transformIndexOnDelete(end, index, length);\r\n            this._changeDetector.removeText(index, length);\r\n            this._updateControl();\r\n            this._setTextSelection(xStart, xEnd);\r\n        };\r\n        TextInputManager.prototype.setText = function (value) {\r\n            this._assertBound();\r\n            this._changeDetector.setValue(value);\r\n            this._updateControl();\r\n            this._setTextSelection(0, 0);\r\n        };\r\n        TextInputManager.prototype.getText = function () {\r\n            return this._control.value;\r\n        };\r\n        TextInputManager.prototype._updateControl = function () {\r\n            this._control.value = this._changeDetector.getValue();\r\n        };\r\n        TextInputManager.prototype._assertBound = function () {\r\n            if (this._changeDetector === null) {\r\n                throw new Error(\"The TextInputManager is not bound.\");\r\n            }\r\n        };\r\n        TextInputManager.prototype._getSelection = function () {\r\n            return { 'start': this._control.selectionStart, 'end': this._control.selectionEnd };\r\n        };\r\n        TextInputManager.prototype._setTextSelection = function (start, end) {\r\n            // this._control.focus();\r\n            this._control.setSelectionRange(start, end);\r\n        };\r\n        return TextInputManager;\r\n    }());\n\n    var CollaborativeTextEditor = /** @class */ (function () {\r\n        function CollaborativeTextEditor(options) {\r\n            var _this = this;\r\n            if (!options) {\r\n                throw new Error(\"options must be defined.\");\r\n            }\r\n            if (!options.control) {\r\n                throw new Error(\"options.control must be defined.\");\r\n            }\r\n            var control = options.control;\r\n            var insertCallback = options.onInsert;\r\n            var deleteCallback = options.onDelete;\r\n            var onInsert = function (index, value) {\r\n                _this._selectionManager.updateSelectionsOnInsert(index, value);\r\n                if (insertCallback) {\r\n                    insertCallback(index, value);\r\n                }\r\n            };\r\n            var onDelete = function (index, length) {\r\n                _this._selectionManager.updateSelectionsOnDelete(index, length);\r\n                if (deleteCallback) {\r\n                    deleteCallback(index, length);\r\n                }\r\n            };\r\n            var onSelectionChanged = options.onSelectionChanged !== undefined ?\r\n                options.onSelectionChanged : function (selection) {\r\n            };\r\n            this._inputManager = new TextInputManager({ control: control, onInsert: onInsert, onDelete: onDelete });\r\n            this._selectionManager = new CollaborativeSelectionManager({ control: control, onSelectionChanged: onSelectionChanged });\r\n        }\r\n        CollaborativeTextEditor.prototype.insertText = function (index, value) {\r\n            this._inputManager.insertText(index, value);\r\n            this._selectionManager.updateSelectionsOnInsert(index, value);\r\n        };\r\n        CollaborativeTextEditor.prototype.deleteText = function (index, length) {\r\n            this._inputManager.deleteText(index, length);\r\n            this._selectionManager.updateSelectionsOnDelete(index, length);\r\n        };\r\n        CollaborativeTextEditor.prototype.setText = function (value) {\r\n            this._inputManager.setText(value);\r\n        };\r\n        CollaborativeTextEditor.prototype.getText = function () {\r\n            return this._inputManager.getText();\r\n        };\r\n        CollaborativeTextEditor.prototype.selectionManager = function () {\r\n            return this._selectionManager;\r\n        };\r\n        return CollaborativeTextEditor;\r\n    }());\n\n    exports.CollaborativeSelectionManager = CollaborativeSelectionManager;\n    exports.CollaboratorSelection = CollaboratorSelection;\n    exports.TextInputManager = TextInputManager;\n    exports.CollaborativeTextEditor = CollaborativeTextEditor;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"file":"html-text-collab-ext.js"}